use std::collections::HashMap;
use std::sync::Arc;

use std::{env, process::exit};

use axum::extract::Query;
use axum::response::{IntoResponse, Response};
use axum_extra::extract::PrivateCookieJar;
use axum_extra::extract::cookie::Cookie;
use openidconnect::core::{
    CoreAuthDisplay, CoreAuthPrompt, CoreErrorResponseType, CoreGenderClaim, CoreJsonWebKey,
    CoreJweContentEncryptionAlgorithm, CoreJwsSigningAlgorithm, CoreRevocableToken, CoreTokenType,
};
use openidconnect::{
    AuthDisplay, AuthPrompt, AuthorizationCode, AuthorizationRequest, Client,
    EmptyAdditionalClaims, EmptyExtraTokenFields, EndpointMaybeSet, EndpointNotSet, EndpointSet,
    IdTokenFields, NonceVerifier, ResponseType, RevocationErrorResponseType, StandardErrorResponse,
    StandardTokenIntrospectionResponse, StandardTokenResponse, TokenResponse,
};
use openidconnect::{
    AuthenticationFlow, ClientId, ClientSecret, CsrfToken, DiscoveryError, HttpClientError,
    IssuerUrl, Nonce, RedirectUrl, Scope,
    core::{CoreClient, CoreProviderMetadata, CoreResponseType},
    reqwest,
    url::ParseError,
};

use axum::{
    Router,
    extract::State,
    response::{Html, Redirect},
    routing::get,
};
use serde::Deserialize;
use tracing::{debug, info};

use crate::webapp::WebappError;
use crate::webapp::state::AppState;

pub fn ms_login_router() -> Router<AppState> {
    let route = Router::new()
        .route("/login_microsoft", get(get_login_microsoft))
        .route("/microsoft/callback", get(get_microsoft_callback));

    route
}

async fn get_login_microsoft(
    State(state): State<AppState>,
    jar: PrivateCookieJar,
) -> Result<(PrivateCookieJar, impl IntoResponse), WebappError> {
    let client = state.ms_oauth_client.clone();

    let (authorize_url, csrf_state, nonce) = client
        .authorize_url(
            AuthenticationFlow::<CoreResponseType>::AuthorizationCode,
            CsrfToken::new_random,
            Nonce::new_random,
        )
        .add_scope(Scope::new("email".to_string()))
        .url();

    Ok((jar, Redirect::to(authorize_url.as_str())))
}

// signature had to be generated by rust-analyzer
pub type MsOauthClient = Client<
    EmptyAdditionalClaims,
    CoreAuthDisplay,
    CoreGenderClaim,
    CoreJweContentEncryptionAlgorithm,
    CoreJsonWebKey,
    CoreAuthPrompt,
    StandardErrorResponse<CoreErrorResponseType>,
    StandardTokenResponse<
        IdTokenFields<
            EmptyAdditionalClaims,
            EmptyExtraTokenFields,
            CoreGenderClaim,
            CoreJweContentEncryptionAlgorithm,
            CoreJwsSigningAlgorithm,
        >,
        CoreTokenType,
    >,
    StandardTokenIntrospectionResponse<EmptyExtraTokenFields, CoreTokenType>,
    CoreRevocableToken,
    StandardErrorResponse<RevocationErrorResponseType>,
    EndpointSet,
    EndpointNotSet,
    EndpointNotSet,
    EndpointNotSet,
    EndpointMaybeSet,
    EndpointMaybeSet,
>;

pub async fn oauth_client() -> Result<MsOauthClient, WebappError> {
    let client_id = ClientId::new(
        env::var("MICROSOFT_CLIENT_ID")
            .expect("Missing the MICROSOFT_CLIENT_ID environment variable."),
    );
    let client_secret = ClientSecret::new(
        env::var("MICROSOFT_CLIENT_SECRET")
            .expect("Missing the MICROSOFT_CLIENT_SECRET environment variable."),
    );
    let tenant_id = env::var("MICROSOFT_TENANT_ID").expect("Missing MICROSOFT_TENANT_ID");
    let redirect_url = env::var("MICROSOFT_REDIRECT_URL").expect("Missing MICROSOFT_REDIRECT_URL");
    let http_client = reqwest::ClientBuilder::new()
        // Following redirects opens the client up to SSRF vulnerabilities.
        .redirect(reqwest::redirect::Policy::none())
        .build()
        .expect("HTTP Client should build");
    let provider_metadata = CoreProviderMetadata::discover_async(
        IssuerUrl::new(format!(
            "https://login.microsoftonline.com/{tenant_id}/v2.0"
        ))?,
        &http_client,
    )
    .await?;
    let client =
        CoreClient::from_provider_metadata(provider_metadata, client_id, Some(client_secret))
            .set_redirect_uri(RedirectUrl::new(redirect_url)?);

    Ok(client)
}

#[derive(Debug, Deserialize)]
#[allow(dead_code)]
struct CallbackParams {
    code: String,
    state: String,
}

fn always_verify_nonce(_nonce: Option<&Nonce>) -> Result<(), String> {
    Ok(())
}

async fn get_microsoft_callback(
    Query(params): Query<CallbackParams>,
    State(client): State<MsOauthClient>,
    jar: PrivateCookieJar,
) -> Result<(PrivateCookieJar, Response), WebappError> {
    // TODO should we store one client and reuse?
    let http_client = reqwest::ClientBuilder::new()
        // Following redirects opens the client up to SSRF vulnerabilities.
        .redirect(reqwest::redirect::Policy::none())
        .build()
        .expect("HTTP Client should build");

    let token_response = client
        .exchange_code(AuthorizationCode::new(params.code.clone()))?
        .request_async(&http_client)
        .await?;

    let id_token = token_response
        .id_token()
        .ok_or(WebappError::MissingIdToken)?;

    let id_token_verifier = client.id_token_verifier();
    let claims = id_token.claims(&id_token_verifier, always_verify_nonce)?;

    let email = claims.email().ok_or(WebappError::MissingEmailError)?;

    // println!("params: {:#?}", params);
    // println!("token_response: {:#?}", token_response);
    // println!("id_token: {:#?}", id_token);
    // println!("claims: {:#?}", claims);
    // println!("email: {}", email.as_str());

    let mut updated_jar = jar.add(Cookie::build(("user", email.to_string())).path("/"));

    if let Some(next_url) = updated_jar.get("next_url") {
        info!("next_url: {:#?}", next_url.value_trimmed());
        updated_jar = updated_jar.remove(Cookie::from("next_url"));
        return Ok((
            updated_jar,
            Redirect::to(next_url.value_trimmed()).into_response(),
        ));
    };

    Ok((
        updated_jar,
        Redirect::to("/").into_response().into_response(),
    ))
}
